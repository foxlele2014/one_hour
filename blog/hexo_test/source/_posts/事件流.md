---
title: 事件流
date: 2018-02-07 16:09:10
tags:
- js
- 事件流
category:
- javascript
---

- 冒泡
- 捕获
- target、currentTarget

### 事件流简介
浏览器事件有三个阶段：
1. 捕获（capturing）：从 window 向目标元素向下传播（很少用）。
2. 目标（target）：到达目标元素并触发其监听器。
3. 冒泡（bubbling）：从目标元素向上冒泡到 window（大多数事件支持冒泡）.

默认 addEventListener 注册的监听器在冒泡阶段触发。可通过第三个参数切换到捕获阶段或传入配置对象。

示例：捕获 vs 冒泡
```html
<div id="outer"><button id="btn">click</button></div>
<script>
const outer = document.getElementById('outer');
const btn = document.getElementById('btn');

// 捕获阶段监听
outer.addEventListener('click', () => console.log('outer capture'), { capture: true });
// 冒泡阶段监听
outer.addEventListener('click', () => console.log('outer bubble'));
btn.addEventListener('click', () => console.log('button handler'));
</script>
```

target 与 currentTarget
- event.target：事件最初的触发源（可能是子元素）。
- event.currentTarget：当前正在处理事件的元素（监听器绑定的元素）.

停止传播
- event.stopPropagation()：阻止后续的捕获或冒泡。
- event.stopImmediatePropagation()：还会阻止当前元素上后续的其他监听器执行。

事件委托（推荐）
把子元素的事件处理器绑定到父元素，利用冒泡统一处理，减少监听器数量。
```javascript
// 委托示例：处理多个 .item 的点击
document.querySelector('#list').addEventListener('click', (e) => {
  const item = e.target.closest('.item');
  if (!item) return;
  // 处理 item
});
```

监听器选项（常用）
- capture: true/false（捕获或冒泡）
- once: true（自动只触发一次后移除）
- passive: true（提示浏览器不会调用 preventDefault，用于触摸/滚动性能）

示例：被动监听器
```javascript
element.addEventListener('touchstart', onTouch, { passive: true });
```
（passive:true 时调用 e.preventDefault() 无效）

实用建议
- 优先使用事件委托处理大量相似子元素的事件。
- 仅在需要时使用捕获。
- 在触摸/滚动事件上考虑 passive 提升性能。
- 使用 stopPropagation/stopImmediatePropagation 小心，避免破坏委托和第三方库逻辑。