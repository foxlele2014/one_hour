---
title: 路由实现
date: 2018-02-07 17:02:40
tags:
- 路由
category:
- javascript
---

- history
- hash
- 原理
- 实现
- 注意点

### 路由实现概述
前端路由用于在单页应用(SPA)中根据 URL 改变显示不同的视图而不重载页面。常见实现方式有两类：基于 hash 的路由和基于 History API 的路由。两者原理不同，各有优缺点。

### 两种路由方式对比
- Hash 路由（#）
  - 原理：监听 location.hash 的变化（hashchange 事件），hash 后面的字符串表示路由状态。
  - 优点：兼容性好，服务器无需特殊配置（因为 URL 的 hash 不发送到服务器）。
  - 缺点：URL 中会带 #，对 SEO 不友好（搜索引擎对 hash 路由抓取有限）。
- History 路由（pushState / popstate）
  - 原理：使用 history.pushState/replaceState 修改浏览器地址栏并借助 popstate 处理前进/后退，URL 看起来像正常路径。
  - 优点：URL 友好、可用于 SEO（配合服务端渲染或服务器路由回退）。
  - 缺点：服务器需要配置回退到 SPA 的入口页面（通常返回 index.html），以避免刷新 404。

### 简单实现示例

- 简单 Hash 路由（最小实现）：
```javascript
// filepath:
// ...existing code...
const routes = {
  '/': () => renderHome(),
  '/about': () => renderAbout(),
  '/post/:id': params => renderPost(params.id)
};

function parseHash() {
  return location.hash.slice(1) || '/';
}

function matchRoute(path) {
  // 简单匹配：优先静态，再尝试带参数的模式（可用更完善的 path-to-regex）
  for (const pattern in routes) {
    if (pattern.includes(':')) {
      const regex = new RegExp('^' + pattern.replace(/:\w+/g, '([^/]+)') + '$');
      const m = path.match(regex);
      if (m) {
        const keys = (pattern.match(/:\w+/g) || []).map(k => k.slice(1));
        const params = Object.fromEntries(keys.map((k, i) => [k, decodeURIComponent(m[i+1])]));
        return { handler: routes[pattern], params };
      }
    } else if (pattern === path) {
      return { handler: routes[pattern], params: {} };
    }
  }
  return null;
}

function onHashChange() {
  const path = parseHash();
  const matched = matchRoute(path);
  if (matched) matched.handler(matched.params);
  else renderNotFound();
}

window.addEventListener('hashchange', onHashChange);
window.addEventListener('load', onHashChange);
```
- 基于 History API 的简单路由：
```javascript
// filepath:
// ...existing code...
function navigateTo(url) {
  history.pushState(null, '', url);
  onLocationChange();
}
function replaceTo(url) {
  history.replaceState(null, '', url);
  onLocationChange();
}
function onLocationChange() {
  const path = location.pathname || '/';
  const matched = matchRoute(path); // reuse matchRoute（需支持不含#的路径）
  if (matched) matched.handler(matched.params);
  else renderNotFound();
}
window.addEventListener('popstate', onLocationChange);
document.addEventListener('click', e => {
  const a = e.target.closest('a');
  if (!a) return;
  const isExternal = a.host !== location.host || a.hasAttribute('target') || a.hasAttribute('download');
  if (!isExternal) {
    e.preventDefault();
    navigateTo(a.pathname);
  }
});
window.addEventListener('load', onLocationChange);
```

### 路由匹配与参数解析

- 推荐使用稳定的路径匹配库（如 path-to-regexp、route-parser），避免手写正则带来的边界问题。
- 注意对参数做 decodeURIComponent/encodeURIComponent，处理空段、尾斜杠一致性。

### 服务端配置（History 路由必需）

- 所有非静态资源的请求应返回 SPA 的入口页（index.html），由前端路由决定视图。
- 对于静态资源（JS/CSS/图片）应保留正常静态处理。
若支持 SSR，请在服务器端做对应路由渲染并返回预渲染 HTML 提升 SEO。

### 边界与注意点

- SEO 与爬虫：Hash 路由对 SEO 不友好；使用 History + SSR 或预渲染可改善。
- 刷新问题：History 路由刷新需服务器回退；Hash 路由无需服务器调整。
- 滚动恢复：处理导航时保存/恢复滚动位置（浏览器默认可能不同）。
- 访问控制：导航守卫（同步/异步）用于鉴权、重定向。
- 性能与内存：避免在路由切换时泄露事件监听器或定时器。
- URL 编码：注意路径与查询的编码/解码、重复斜杠、尾随斜杠的规范化。
- 后退/替换：用 replaceState 做无需历史记录的替换（如登录后替换回上一个状态）。

### 实践建议

- 小项目或兼容性要求高：hash 路由快速简单。
- 生产级 SPA：优先 history 路由 + 服务端配置或 SSR。
- 使用成熟路由库（Vue Router / React Router / router5 等）来减少坑与提升功能（懒加载、嵌套路由、导航守卫、滚动行为等）。
- 提前考虑基路径(base)、404/重定向策略与国际化路由设计。

小结：理解 hash 与 history 的原理与权衡，再根据项目需求选择实现方式与工具，能避免常见的刷新、SEO、服务器配置等问题。