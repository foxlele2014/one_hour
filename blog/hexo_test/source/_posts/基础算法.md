---
title: 基础算法
date: 2018-02-07 15:43:14
tags:
- 数据结构
category:
- 算法
---

- 快速排序

### 常见基础算法速览（简明）

- 快速排序（Quick Sort）
  - 思路：分治，选基准 pivot，把数组分为小于 pivot / 等于 / 大于，然后递归排序。
  - 平均时间复杂度：O(n log n)，最坏 O(n^2)（可随机化或三数取中减少概率）。
  - 原地实现常用，空间 O(log n) 递归栈。

示例（JS）：
```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = [], mid = [], right = [];
  for (const x of arr) {
    if (x < pivot) left.push(x);
    else if (x === pivot) mid.push(x);
    else right.push(x);
  }
  return quickSort(left).concat(mid, quickSort(right));
}
```

- 归并排序（Merge Sort）
  - 思路：分而治之，递归拆半，合并时做有序合并。
  - 时间复杂度：O(n log n)，稳定；空间复杂度 O(n)。

- 堆排序（Heap Sort）
  - 利用二叉堆（最大堆）选择最大元素，原地排序，时间 O(n log n)，不稳定。

- 二分查找（Binary Search）
  - 前提：有序数组。
  - 时间复杂度：O(log n)。

示例（JS，迭代）：
```javascript
function binarySearch(arr, target) {
  let l = 0, r = arr.length - 1;
  while (l <= r) {
    const m = (l + r) >> 1;
    if (arr[m] === target) return m;
    if (arr[m] < target) l = m + 1;
    else r = m - 1;
  }
  return -1;
}
```

- 图的遍历：DFS / BFS
  - DFS（深度优先）：递归或栈实现，适合拓扑、连通性、回溯问题。
  - BFS（宽度优先）：队列实现，适合最短步数（无权图）。

- 常见数据结构速记
  - 数组、链表、栈、队列、哈希表（Map/Set）、二叉树、堆、并查集、Trie、图（邻接表/矩阵）。

- 算法复杂度与常见陷阱
  - 关注时间复杂度与空间复杂度，注意常数项与递归深度。
  - 输入规模边界（空集、重复、大量重复值、极端有序/逆序）要单独考虑。
  - 优先写清晰正确的解法，再考虑微观优化（位运算、预分配、原地变更）。

- 练习建议
  - 从经典题目入手：排序、二分、滑动窗口、哈希映射、DFS/BFS、双指针、动态规划基础。
  - 理解常用模板（递归、二分、滑窗口、前缀和、差分、堆）并能变形应用。

小结：掌握排序、查找、图遍历与基本数据结构，理解复杂度与边界情况，是攻克中等算法题的基石。